// generates torso state file for skylimit
// by jv_map

main:
	level.scr_cur_line = 0

	level.loop_protection = 0

	waitthread addheader
	
	group.allkeycombos = waitthread makekeycombos
	
	waitthread addSTAND
	
	// do other states
	waitthread dostates
	
	wait 1.0
	
	thread dump
end

addheader:
	waitthread addln "// this file was automatically generated by statefile_gen.scr"
	waitthread addln ""
end

addSTAND:
	// general stuff
	waitthread addln "state STAND"
	waitthread addln "{"
	waitthread addln "	camera behind"
	waitthread addln "	movetype anim"
	waitthread addln ""
	waitthread addln "	states"
	waitthread addln "	{"
	
	// add key-dependent states here
	for(local.i = 1; local.i <= group.allkeycombos.size; local.i++)
	{
		local.combo = group.allkeycombos[local.i]
		local.comboarray = waitthread global/skylimit/string.scr::string_to_array local.combo "-"
		
		// make condition string
		local.condstr = ""
		for(local.j = 1; local.j <= local.comboarray.size; local.j++)
		{
			local.condstr += local.comboarray[local.j]
			if(local.j < local.comboarray.size)
				local.condstr += " "
		}	
		waitthread addln ("		" + local.combo + " : " + local.condstr)
	}
	
	waitthread addln "		NONE : default"
	waitthread addln "	}"
	waitthread addln "}"
	waitthread addln ""
end

dostates:
	for(local.i = 1; local.i <= group.allkeycombos.size; local.i++)
	{
		local.combo = group.allkeycombos[local.i]
		waitthread addstate local.combo
		waitthread addln ""
		
		if(local.i % 100 == 1)
			waitframe
	}
	waitthread addstate NIL "NONE" 0
	waitthread addln ""
end

addstate local.combo local.name local.keyint:
	if (local.name == NIL)
		local.name = local.combo

	if (local.keyint == NIL)
		local.keyint = waitthread combostrtoint local.combo

	waitthread addln ("state " + local.name)
	waitthread addln "{"
	waitthread addln "	entrycommands"
	waitthread addln "	{"
	waitthread addln ("		exec global/skylimit/input.scr set_next_input " + local.keyint)
	waitthread addln "		moveposflags \"crouching\""
	waitthread addln "		commanddelay 0.05 moveposflags \"standing\""
	waitthread addln "	}"
	
	waitthread addln "	states"
	waitthread addln "	{"
	waitthread addln "		STAND : POSITION_TYPE \"standing\""
	waitthread addln "	}"
	waitthread addln "}"
end

combostrtoint local.combo:
	local.array = waitthread global/skylimit/string.scr::string_to_array local.combo "-"
	
	local.int = 0
	
	for(local.i = 1; local.i <= local.array.size; local.i++)
	{
		local.keyid = waitthread getkeyid local.array[local.i]
		local.keyint = level.SL_INPUT_KEYINT[local.keyid]
		local.int = local.int | local.keyint
	}
end local.int

getkeyid local.keystr:
	for(local.i = 1; local.i <= level.SL_INPUT_CONDITIONS.size; local.i++)
	{
		if(level.SL_INPUT_CONDITIONS[local.i] == local.keystr)
			end local.i
	}
	println "failed to find keyID!"
end ( -1)

makekeycombos:
	local.keys = level.SL_INPUT_CONDITIONS
	// FORWARD::BACKWARD::STRAFE_LEFT::STRAFE_RIGHT::RUN::CROUCH::JUMP::ATTACK_PRIMARY::ATTACK_SECONDARY::RELOAD::PUTAWAYMAIN::NEW_WEAPON
	
	// relative index to which a key is linked
	// this rules out 'impossible' key combos like FORWARD-BACKWARD
	local.rellinkindex = 1::( -1)::1::( -1)::0::1::( -1)::0::0::0::0::0
	
	if(local.rellinkindex.size != local.keys.size)
	{
		println "ERROR[statfile_gen::makekeycombos]: Rellinkindex mismatch!"
		end
	}
	
	local.k = 0
	
	// create binary combos
	local.numcombos = (waitthread global/skylimit/math.scr::ipowint 2 local.keys.size) - 1
	for(local.i = 1; local.i <= local.numcombos; local.i++)
	{
		local.bincombostr = waitthread inttobinary local.keys.size local.i
		
		local.curcombostr = ""
		for(local.j = 0; local.j < local.bincombostr.size; local.j++)
		{
			if(local.bincombostr[local.j] == "1")
			{
				local.linkindex = local.j + local.rellinkindex[local.j + 1]
				local.linkchar = local.bincombostr[local.linkindex]
				
				// linkchar may not be '1'
				if(local.linkindex != local.j && local.linkchar == "1")
				{
					// this combo is invalid, break!
					local.curcombostr = ""
					break	
				}
				else
					local.curcombostr += local.keys[local.j + 1] + "-"
			}
		}
		if(local.curcombostr != "")
		{
			// trim trailing '-'
			local.curcombostr = waitthread substring local.curcombostr 0 (local.curcombostr.size - 2)
			
			local.k++
			local.combostr[local.k] = local.curcombostr
			
			//println local.curcombostr
		}
	}
	
	// flip indexes so most complicated states get selected first
	local.j = 0
	for(local.i = local.combostr.size; local.i >= 1; local.i--)
	{
		local.j++
		local.flippedcombostr[local.j] = local.combostr[local.i]
	}
end local.flippedcombostr

// returns binary string representation of int
// dim is number of bits
// num must be an integer
inttobinary local.dim local.num:
	local.str = ""
	local.curnum = local.num
	local.i = local.dim - 1
	
	while(local.i >= 0)
	{
		local.bitval = waitthread global/skylimit/math.scr::ipowint 2 local.i
		local.bool = local.curnum >= local.bitval
		if(local.bool)
		{
			local.curnum -= local.bitval	
		}
		local.str += local.bool
		local.i--
	}
end local.str

// returns part of string str
// starting at char index start
// ending at char index end
substring local.str local.start local.end:
	local.outstr = ""
	for(local.i = local.start; local.i <= local.end; local.i++)
	{
		local.outstr += local.str[local.i]
	}
end local.outstr

addln local.str local.tabs:
	// adds a line to the script
	level.scr_cur_line++
	
	if(local.tabs == NIL)
		local.tabs = 0
	
	local.str_prefix = ""
	for(local.i = 1; local.i <= local.tabs; local.i++)
		local.str_prefix += "\t"
	
	// TODO: might have a problem when this gets too large..
	level.scr[level.scr_cur_line] = local.str_prefix + local.str
end

dump:
	level.loop_protection = 0
	println "////////////////////////////////////////"
	for(local.i = 1; local.i <= level.scr_cur_line; local.i++)
	{
		println level.scr[local.i]
		if(local.i%160 == 1)
			waitframe
	}
	println "////////////////////////////////////////"
end