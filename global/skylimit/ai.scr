// very(!) basic AI
// by jv_map

main:
	wait 2.0

	for(local.i = 1; local.i <= 0; local.i++)
	{
		wait 0.1
		thread botloop allies local.i
	}
	for(local.i = 1; local.i <= 0; local.i++)
	{
		wait 0.1
		thread botloop axis local.i
	}
end

botloop local.team local.delay:
	while(1)
	{
		local.pilot = spawn listener // so it can have a targetname
		local.pilot.dmteam = local.team
		local.pilot.script_viewangles = (0 0 0)
		local.pilot.SL_ucmd = waitthread ucmd_none
		
        local.optnum = 0
		while(1)
		{
			while !(local.pilot waitthread level.SL_GAMETYPESCR::canrespawn)
			{
				wait 0.5
			}
			
			if(level.SL_FINITE_PLANES && level.SL_SERVICEABLE_PLANES[local.team] <= 0)
			{
				local.pilot remove
				end
			}
			
			//local.optnum = randomint level.SL_PLANEOPTIONS[local.pilot.dmteam].size + 1
            local.optnum++
			local.plane_opt = level.SL_PLANEOPTIONS[local.pilot.dmteam][local.optnum]
			if( !level.SL_FINITE_PLANES || level.SL_SERVICEGROUPS[local.team][local.plane_opt.servicegroup] > 0)
			{
				break
			}
			waitframe
		}
		
		local.plane = spawn Animate
		
		local.plane thread global/skylimit/flight.scr::fly local.pilot local.plane_opt
		
        if ( !local.plane.airspawn)
        {
            waitthread takeoff local.plane local.pilot
        }
		
        if (!local.pilot.killed)
            waitthread fly_like_a_pro local.plane local.pilot

        local.pilot remove            
		wait 5.0
	}
end

takeoff local.plane local.pilot:

    // start engine
    local.pilot.SL_ucmd[BRAKE] = game.true
    local.pilot.SL_ucmd[THROTTLE_UP] = game.true
    
    while (!local.pilot.killed && local.plane && !local.plane.engine_started)
        waitframe

    wait 0.5
    local.pilot.SL_ucmd[THROTTLE_UP] = game.false
    wait 0.5
    local.pilot.SL_ucmd[THROTTLE_UP] = game.true

    // give prop some time to spin up
    wait 3.0
    local.pilot.SL_ucmd[BRAKE] = game.false
    
    // take off run	
        
    local.af_height = local.plane.origin[2]
    while(!local.pilot.killed && local.plane && local.plane.onground)
    {
        // keep wings level
        if(local.plane.leftvector[2] < -0.1)
        {
            local.pilot.SL_ucmd[ROLL_LEFT]  = game.false
            local.pilot.SL_ucmd[ROLL_RIGHT] = game.true
        }
        else if(local.plane.leftvector[2] > 0.1)
        {
            local.pilot.SL_ucmd[ROLL_LEFT]  = game.true
            local.pilot.SL_ucmd[ROLL_RIGHT] = game.false
        }
        else
        {
            local.pilot.SL_ucmd[ROLL_LEFT]  = game.false
            local.pilot.SL_ucmd[ROLL_RIGHT] = game.false
        }
        
        // don't sink
        if(local.plane.p_velocity[2] < 0)
        {
            local.pilot.SL_ucmd[PITCH_UP] = game.true
        }
        else
        {
            local.pilot.SL_ucmd[PITCH_UP] = game.false
        }
        waitframe
    }
    
    local.pilot.SL_ucmd[PITCH_UP] = game.true
    wait 0.5
    local.pilot.SL_ucmd[TOGGLE_GEAR] = game.true
    waitframe
    local.pilot.SL_ucmd[TOGGLE_GEAR] = game.false
    
    // climb 
    local.climb_pitch = 20.0 // deg
    local.release_height = 300.0 // m
    while(!local.pilot.killed && local.plane && local.plane.origin[2] - local.af_height <= local.release_height / level.SL_UNITSCALE)
    {
        // keep wings level
        if(local.plane.leftvector[2] < -0.1)
        {
            local.pilot.SL_ucmd[ROLL_LEFT]  = game.false
            local.pilot.SL_ucmd[ROLL_RIGHT] = game.true
        }
        else if(local.plane.leftvector[2] > 0.1)
        {
            local.pilot.SL_ucmd[ROLL_LEFT]  = game.true
            local.pilot.SL_ucmd[ROLL_RIGHT] = game.false
        }
        else
        {
            local.pilot.SL_ucmd[ROLL_LEFT]  = game.false
            local.pilot.SL_ucmd[ROLL_RIGHT] = game.false
        }
        
        if(local.plane.p_pitch < local.climb_pitch)
        {
            local.pilot.SL_ucmd[PITCH_UP] = game.true
        }
        else
        {
            local.pilot.SL_ucmd[PITCH_UP] = game.false
        }
        waitframe
    }
end

fly_like_a_pro local.plane local.pilot:
    //local.target_attitude_nvec = vector_normalize ( -0.5 0.4 0.1) // ( 1.0 0.1 0.0)
    local.target_attitude_roll = 0.0
    //local.target_angles = (0 0 0)
    
    local.pilot.SL_ucmd[PITCH_UP] 	= game.false
    local.pilot.SL_ucmd[PITCH_DOWN] = game.false
    local.pilot.SL_ucmd[ROLL_LEFT]  = game.false
    local.pilot.SL_ucmd[ROLL_RIGHT] = game.false
    
    local.turning = false
    
    while(!local.pilot.killed && local.plane)
    {
        local.target_attitude_nvec = vector_normalize (level.ai_target[local.pilot.dmteam] - local.plane.origin)
        
        //local.target_attitude_roll = (int (90 * level.time)) % 360 - 180
        
        // first get yaw right
        local.fwd_dot = local.plane.forwardvector * local.target_attitude_nvec
        
        if ((local.turning && local.fwd_dot > 0.95) || (!local.turning && local.fwd_dot > 0.90))
        {
            local.turning = game.false
            
            // very shallow turn
            local.proj_up_dot = local.target_attitude_nvec * local.plane.upvector
            local.pitchrate = local.plane.p_avelocity * local.plane.leftvector
            local.pitchfact = 0.5 * local.proj_up_dot + 0.25 * local.pitchrate
            //println "pitchfact " (0.5 * local.proj_up_dot) " " (0.25 * local.pitchrate)
            local.pilot.SL_ucmd[PITCH_UP] 	= local.pitchfact > 0.01
            local.pilot.SL_ucmd[PITCH_DOWN] = local.pitchfact < -0.01
            
            local.roll_angle_diff = waitthread global/skylimit/math.scr::getanglediff local.plane.angles[2] local.target_attitude_roll
            if (game.false && local.roll_angle_diff < -60.0)
            {
                local.pilot.SL_ucmd[ROLL_LEFT]  = game.true
                local.pilot.SL_ucmd[ROLL_RIGHT] = game.false
            }
            else if (game.false && local.roll_angle_diff > 60.0)
            {
                local.pilot.SL_ucmd[ROLL_LEFT]  = game.false
                local.pilot.SL_ucmd[ROLL_RIGHT] = game.true
            }
            else
            {
                local.proj_lf_dot = local.target_attitude_nvec * local.plane.leftvector
                local.rollrate = local.plane.p_avelocity * local.plane.forwardvector
                local.rollfact = -0.005 * local.roll_angle_diff + 0.25 * local.plane.upvector[2] * local.proj_lf_dot + 0.1 * local.rollrate
                //println "rollfact: " ( -0.005 * local.roll_angle_diff) " " (  0.25 * local.plane.upvector[2] * local.proj_lf_dot) " "  (0.1 * local.rollrate)
                local.pilot.SL_ucmd[ROLL_LEFT]  = local.rollfact > 0.01
                local.pilot.SL_ucmd[ROLL_RIGHT] = local.rollfact < -0.01
            }
            
            println "local.plane.angles: " local.plane.angles
        }
        else if (game.false && local.fwd_dot > 0.5)
        {
            // shallow turn (TODO?)
            local.pilot.SL_ucmd[PITCH_UP] 	= game.false
            local.pilot.SL_ucmd[PITCH_DOWN] = game.false
            local.pilot.SL_ucmd[ROLL_LEFT]  = game.false
            local.pilot.SL_ucmd[ROLL_RIGHT] = game.false
        }
        else
        {
            local.turning = game.true
            /*
            local.turn_vec = vector_cross local.plane.forwardvector local.target_attitude_nvec
            local.turn_vec_len = vector_length local.turn_vec
            
            if (local.turn_vec_len == 0.0)
            {
                // edge case: I want to go exactly the other way.
                local.pilot.SL_ucmd[PITCH_UP] 	= game.true
                local.pilot.SL_ucmd[PITCH_DOWN] = game.false
                local.pilot.SL_ucmd[ROLL_LEFT]  = game.false
                local.pilot.SL_ucmd[ROLL_RIGHT] = game.true
            }
            else
            {
                // try to align right vector with turn vec, then pull up
                local.proj_lf_dot = -1 * (local.turn_vec * local.plane.leftvector) / local.turn_vec_len
                local.rollrate = local.plane.p_avelocity * local.plane.forwardvector
                local.rollfact = local.proj_lf_dot + 0.5 * local.rollrate
                if (local.rollfact > 0.01)
                {
                    // turn (more) left
                    local.pilot.SL_ucmd[ROLL_LEFT]  = game.true
                    local.pilot.SL_ucmd[ROLL_RIGHT] = game.false
                } 
                else if (local.rollfact < -0.01)
                {
                    // turn (more) right
                    local.pilot.SL_ucmd[ROLL_LEFT]  = game.false
                    local.pilot.SL_ucmd[ROLL_RIGHT] = game.true
                }
                else
                {
                    local.pilot.SL_ucmd[ROLL_LEFT]  = game.false
                    local.pilot.SL_ucmd[ROLL_RIGHT] = game.false
                }
            }
            */
            
            // steep turn
            // TODO: proper turn inclination (should be more horizontal)
            // maybe use an aimvec when going around?                  
            //if (local.fwd_dot >= 0)
                local.aimvec = local.target_attitude_nvec
            //else
            //    local.aimvec = ...?? // ignore upvector component? but the upvector doesn't matter...
            
            // first get roll angle right for the turn
            // project target vector on (lf,up)-plane
            
            local.proj = local.aimvec - local.fwd_dot * local.plane.forwardvector
            local.proj_len = vector_length local.proj
            if (local.proj_len == 0.0)
            {
                // edge case: I want to go exactly the other way.
                local.pilot.SL_ucmd[PITCH_UP] 	= game.true
                local.pilot.SL_ucmd[PITCH_DOWN] = game.false
                local.pilot.SL_ucmd[ROLL_LEFT]  = game.false
                local.pilot.SL_ucmd[ROLL_RIGHT] = game.true
            }
            else
            {
                //local.proj_lf_dot = (local.proj * local.plane.leftvector) / local.proj_len
                local.proj_lf_dot = (local.aimvec * local.plane.leftvector) / local.proj_len
                local.rollrate = local.plane.p_avelocity * local.plane.forwardvector
                local.rollfact = local.proj_lf_dot + local.rollrate
                if (local.rollfact > 0.01)
                {
                    // turn (more) left
                    local.pilot.SL_ucmd[ROLL_LEFT]  = game.true
                    local.pilot.SL_ucmd[ROLL_RIGHT] = game.false
                } 
                else if (local.rollfact < -0.01)
                {
                    // turn (more) right
                    local.pilot.SL_ucmd[ROLL_LEFT]  = game.false
                    local.pilot.SL_ucmd[ROLL_RIGHT] = game.true
                }
                else
                {
                    local.pilot.SL_ucmd[ROLL_LEFT]  = game.false
                    local.pilot.SL_ucmd[ROLL_RIGHT] = game.false
                }
                // pull up or push down if roll angle is good enough
                //local.proj_up_dot = (local.proj * local.plane.upvector) / local.proj_len
                //local.pilot.SL_ucmd[PITCH_UP] = local.proj_up_dot >= -0.2 // 0.1
                //local.pilot.SL_ucmd[PITCH_DOWN] = local.proj_up_dot < -0.2
                if (abs local.rollfact < 0.1)
                {
                    local.pilot.SL_ucmd[PITCH_UP] = game.true
                    local.pilot.SL_ucmd[PITCH_DOWN] = game.false
                }
            }
        }        
        waitframe
    }
end

fly_like_an_idiot local.plane local.pilot:

	local.update_turn_time = 0.0
	
	while(!local.pilot.killed && local.plane)
	{
		if(local.plane.origin[2] <= $world.OBSTACLEHEIGHT + 500.0 && local.plane.p_velocity[2] <= 0.0)
		{		
			if(local.plane.leftvector[2] < -0.5)
			{
				local.pilot.SL_ucmd[PITCH_UP] 	= game.false
				local.pilot.SL_ucmd[PITCH_DOWN] = game.false
				local.pilot.SL_ucmd[ROLL_LEFT]  = game.false
				local.pilot.SL_ucmd[ROLL_RIGHT] = game.true
			}
			else if(local.plane.leftvector[2] > 0.5)
			{
				local.pilot.SL_ucmd[PITCH_UP] 	= game.false
				local.pilot.SL_ucmd[PITCH_DOWN] = game.false
				local.pilot.SL_ucmd[ROLL_LEFT]  = game.true
				local.pilot.SL_ucmd[ROLL_RIGHT] = game.false
			}
			else
			{
				local.pilot.SL_ucmd[ROLL_LEFT]  = game.false
				local.pilot.SL_ucmd[ROLL_RIGHT] = game.false
				if(local.plane.upvector[2] >= 0.0)
				{
					local.pilot.SL_ucmd[PITCH_UP] 		= game.true
					local.pilot.SL_ucmd[PITCH_DOWN] 	= game.false
				}
				else
				{
					local.pilot.SL_ucmd[PITCH_UP] 		= game.false
					local.pilot.SL_ucmd[PITCH_DOWN] 	= game.true
				}
			}
		}
		else if(level.time > local.update_turn_time)
		{
			local.pilot.SL_ucmd[PITCH_UP] 		= randomint 2
			local.pilot.SL_ucmd[PITCH_DOWN] 	= randomint 2 //!local.pilot.SL_ucmd[PITCH_UP]
			local.pilot.SL_ucmd[ROLL_LEFT] 		= randomint 2
			local.pilot.SL_ucmd[ROLL_RIGHT] 	= randomint 2 //!local.pilot.SL_ucmd[ROLL_LEFT]
			
			local.update_turn_time = level.time + ((1 + randomint 20) * 0.05)
		}
		wait 0.05		
	}
end

ucmd_none:
	local.ucmd[PITCH_UP] 			= game.false
	local.ucmd[PITCH_DOWN] 			= game.false
	local.ucmd[ROLL_LEFT] 			= game.false
	local.ucmd[ROLL_RIGHT] 			= game.false
	local.ucmd[ATTACK_PRIMARY] 		= game.false
	local.ucmd[ATTACK_SECONDARY] 	= game.false
	local.ucmd[TOGGLE_GEAR] 		= game.false
	local.ucmd[THROTTLE_UP] 		= game.false
	local.ucmd[THROTTLE_DN] 		= game.false
	local.ucmd[BRAKE] 				= game.false
	local.ucmd[TOGGLE_NOSE_CAM] 	= game.false
	local.ucmd[THRUST_REVERSE] 		= game.false
	local.ucmd[CAM_FREE] 			= game.false
	local.ucmd[ITEM_NEXT] 			= game.false
	local.ucmd[ITEM_PREV] 			= game.false
end local.ucmd